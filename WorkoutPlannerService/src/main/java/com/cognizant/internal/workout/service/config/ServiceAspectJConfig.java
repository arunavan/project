package com.cognizant.internal.workout.service.config;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Controller;import org.springframework.util.StopWatch;import com.cognizant.internal.workout.service.exception.ServiceApplicationException;/** * AspectJConfig to define AOP configurations */@Controller@Aspectpublic class ServiceAspectJConfig {    private static final String DOT                = ".";    private static final String COMMA              = ",";    private static final String CLOSINGBRACE       = ")";    private static final String OPENINGBRACE       = "(";    private static final String PROPERTIES_MANAGER = "PropertiesManager";    private static final Logger LOGGER             = LoggerFactory.getLogger(ServiceAspectJConfig.class);    /**     * Logs the time taken by the methods     *      * @param inJoinPoint the ProceedingJoinPoint     * @return Object     * @throws ServiceApplicationException it may throw Business exception if there is any kind of error occurs in operating the data     */    @Around("execution(* com.cognizant.internal.workout.service.rest..*.*(..)) || execution(* com.cognizant.internal.workout.business.manager..*.*(..)) || execution(* com.cognizant.internal.workout.business.dao..*.*(..)) || execution(* com.cognizant.internal.workout.business.helper..*.*(..))")    public Object logTimeMethod(final ProceedingJoinPoint inJoinPoint) throws ServiceApplicationException {        // Before calling        preInvokeLogMessage(inJoinPoint);        // Get Execution Time        final StopWatch theStopWatch = new StopWatch();        theStopWatch.start();        Object theReturnValue;        try {            theReturnValue = inJoinPoint.proceed();        }catch (final ServiceApplicationException inEx) {            throw inEx;        }catch (final Throwable inEx) {            throw new ServiceApplicationException(inEx);        }        theStopWatch.stop();        // After calling        postInvokeLogMessage(inJoinPoint, theStopWatch);        return theReturnValue;    }    /**     * After logging message     *      * @param inJoinPoint the ProceedingJoinPoint     * @param theStopWatch the StopWatch     */    private void postInvokeLogMessage(final ProceedingJoinPoint inJoinPoint, final StopWatch theStopWatch) {        if (LOGGER.isTraceEnabled()) {            if (inJoinPoint.getTarget().getClass().getName().contains(PROPERTIES_MANAGER)) {                return;            }            final StringBuilder theLogMessage = new StringBuilder();            theLogMessage.append(inJoinPoint.getTarget().getClass().getName()).append(DOT);            theLogMessage.append(inJoinPoint.getSignature().getName()).append(" has taken  ");            theLogMessage.append(theStopWatch.getTotalTimeMillis()).append(" ms");            LOGGER.trace(theLogMessage.toString());        }    }    /**     * Before logging message     *      * @param inJoinPoint the ProceedingJoinPoint     */    private void preInvokeLogMessage(final ProceedingJoinPoint inJoinPoint) {        if (LOGGER.isTraceEnabled()) {            if (inJoinPoint.getTarget().getClass().getName().contains(PROPERTIES_MANAGER)) {                return;            }            final StringBuilder theLogMessage = new StringBuilder("Calling ");            theLogMessage.append(inJoinPoint.getTarget().getClass().getName()).append(DOT);            theLogMessage.append(inJoinPoint.getSignature().getName()).append(OPENINGBRACE);            final Object[] args = inJoinPoint.getArgs();            for (int argCounter = 0; argCounter < args.length; argCounter++) {                theLogMessage.append(args[argCounter]).append(COMMA);            }            if (args.length > 0) {                theLogMessage.deleteCharAt(theLogMessage.length() - 1);            }            theLogMessage.append(CLOSINGBRACE);            LOGGER.trace(theLogMessage.toString());        }    }}